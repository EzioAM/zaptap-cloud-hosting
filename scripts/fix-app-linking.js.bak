const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

const supabaseUrl = process.env.SUPABASE_URL || 'https://gfkdclzgdlcvhfiujkwz.supabase.co';
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_ANON_KEY;

if (!supabaseKey) {
  console.error('‚ùå Error: SUPABASE_SERVICE_ROLE_KEY or SUPABASE_ANON_KEY not found in environment variables');
  console.log('For full fixes, set SUPABASE_SERVICE_ROLE_KEY in your .env file');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey, {
  auth: {
    autoRefreshToken: false,
    persistSession: false
  }
});

console.log('üîß Fixing App Linking Setup...\n');

async function executeSql(sql, description) {
  console.log(`\nüìù ${description}...`);
  try {
    const { data, error } = await supabase.rpc('exec_sql', { sql_query: sql }).catch(() => ({ data: null, error: 'Custom RPC not available' }));
    
    if (error === 'Custom RPC not available') {
      // Try direct query through Supabase client (won't work for DDL)
      console.log('‚ö†Ô∏è  Direct SQL execution not available. Please run the following SQL in Supabase SQL Editor:');
      console.log('\n```sql');
      console.log(sql);
      console.log('```\n');
      return false;
    }
    
    if (error) {
      console.log(`‚ùå Error: ${error}`);
      return false;
    }
    
    console.log('‚úÖ Success');
    return true;
  } catch (err) {
    console.log(`‚ùå Error: ${err.message}`);
    return false;
  }
}

async function createPublicSharesTable() {
  const sql = `
-- Create public_shares table if it doesn't exist
CREATE TABLE IF NOT EXISTS public.public_shares (
    id text PRIMARY KEY,
    automation_id uuid NOT NULL,
    automation_data jsonb NOT NULL,
    created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    access_count integer DEFAULT 0 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    last_accessed_at timestamp with time zone,
    metadata jsonb DEFAULT '{}' NOT NULL
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_public_shares_automation_id ON public.public_shares(automation_id);
CREATE INDEX IF NOT EXISTS idx_public_shares_expires_at ON public.public_shares(expires_at);
CREATE INDEX IF NOT EXISTS idx_public_shares_is_active ON public.public_shares(is_active);
CREATE INDEX IF NOT EXISTS idx_public_shares_created_by ON public.public_shares(created_by);

-- Add comments
COMMENT ON TABLE public.public_shares IS 'Stores publicly shareable links for automations';
COMMENT ON COLUMN public.public_shares.id IS 'Unique short ID for the share URL';
COMMENT ON COLUMN public.public_shares.automation_data IS 'Full automation data snapshot at share time';
COMMENT ON COLUMN public.public_shares.access_count IS 'Number of times this share has been accessed';
`;

  return await executeSql(sql, 'Creating public_shares table');
}

async function createSharingLogsTable() {
  const sql = `
-- Create sharing_logs table for analytics
CREATE TABLE IF NOT EXISTS public.sharing_logs (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    automation_id uuid NOT NULL,
    share_id text REFERENCES public.public_shares(id) ON DELETE CASCADE,
    method text NOT NULL CHECK (method IN ('link', 'email', 'sms', 'qr', 'nfc')),
    recipients text[] DEFAULT '{}',
    shared_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    shared_at timestamp with time zone DEFAULT now() NOT NULL,
    metadata jsonb DEFAULT '{}' NOT NULL
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_sharing_logs_automation_id ON public.sharing_logs(automation_id);
CREATE INDEX IF NOT EXISTS idx_sharing_logs_share_id ON public.sharing_logs(share_id);
CREATE INDEX IF NOT EXISTS idx_sharing_logs_shared_by ON public.sharing_logs(shared_by);
CREATE INDEX IF NOT EXISTS idx_sharing_logs_shared_at ON public.sharing_logs(shared_at DESC);
`;

  return await executeSql(sql, 'Creating sharing_logs table');
}

async function enableRLS() {
  const sql = `
-- Enable RLS on tables
ALTER TABLE public.public_shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sharing_logs ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Public shares are viewable by anyone" ON public.public_shares;
DROP POLICY IF EXISTS "Users can create their own public shares" ON public.public_shares;
DROP POLICY IF EXISTS "Users can update their own public shares" ON public.public_shares;
DROP POLICY IF EXISTS "Users can delete their own public shares" ON public.public_shares;
DROP POLICY IF EXISTS "Anyone can increment access count" ON public.public_shares;

-- Create RLS policies for public_shares
CREATE POLICY "Public shares are viewable by anyone"
    ON public.public_shares FOR SELECT
    USING (is_active = true AND expires_at > now());

CREATE POLICY "Users can create their own public shares"
    ON public.public_shares FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can update their own public shares"
    ON public.public_shares FOR UPDATE
    USING (auth.uid() = created_by)
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can delete their own public shares"
    ON public.public_shares FOR DELETE
    USING (auth.uid() = created_by);

-- Special policy to allow anonymous users to increment access count
CREATE POLICY "Anyone can increment access count"
    ON public.public_shares FOR UPDATE
    USING (is_active = true AND expires_at > now())
    WITH CHECK (
        -- Only allow updating access_count and last_accessed_at
        (access_count = (OLD.access_count + 1)) AND
        (last_accessed_at = now()) AND
        -- Ensure other fields remain unchanged
        (id = OLD.id) AND
        (automation_id = OLD.automation_id) AND
        (automation_data = OLD.automation_data) AND
        (created_by IS NOT DISTINCT FROM OLD.created_by) AND
        (created_at = OLD.created_at) AND
        (expires_at = OLD.expires_at) AND
        (is_active = OLD.is_active) AND
        (metadata = OLD.metadata)
    );

-- Drop existing policies for sharing_logs if they exist
DROP POLICY IF EXISTS "Users can view their own sharing logs" ON public.sharing_logs;
DROP POLICY IF EXISTS "Users can create sharing logs" ON public.sharing_logs;

-- Create RLS policies for sharing_logs
CREATE POLICY "Users can view their own sharing logs"
    ON public.sharing_logs FOR SELECT
    USING (auth.uid() = shared_by);

CREATE POLICY "Users can create sharing logs"
    ON public.sharing_logs FOR INSERT
    WITH CHECK (auth.uid() = shared_by);
`;

  return await executeSql(sql, 'Setting up RLS policies');
}

async function createHelperFunctions() {
  const sql = `
-- Function to get public share data (works for anonymous users)
CREATE OR REPLACE FUNCTION public.get_public_share(share_id text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    share_data jsonb;
BEGIN
    -- Get share data and increment access count
    UPDATE public.public_shares
    SET 
        access_count = access_count + 1,
        last_accessed_at = now()
    WHERE 
        id = share_id AND
        is_active = true AND
        expires_at > now()
    RETURNING jsonb_build_object(
        'id', id,
        'automation_id', automation_id,
        'automation_data', automation_data,
        'created_at', created_at,
        'expires_at', expires_at,
        'access_count', access_count
    ) INTO share_data;
    
    RETURN share_data;
END;
$$;

-- Function to clean up expired shares
CREATE OR REPLACE FUNCTION public.cleanup_expired_shares()
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    deleted_count integer;
BEGIN
    DELETE FROM public.public_shares
    WHERE expires_at < now() - INTERVAL '7 days'
    RETURNING COUNT(*) INTO deleted_count;
    
    RETURN deleted_count;
END;
$$;

-- Grant execute permissions
GRANT EXECUTE ON FUNCTION public.get_public_share(text) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.cleanup_expired_shares() TO authenticated;
`;

  return await executeSql(sql, 'Creating helper functions');
}

async function createTestData() {
  console.log('\nüß™ Creating test share link...');
  
  try {
    // Create a test automation
    const testAutomation = {
      id: '11111111-1111-1111-1111-111111111111',
      title: 'Test Welcome Automation',
      description: 'A test automation for verifying share links work',
      steps: [
        {
          id: 'step1',
          type: 'notification',
          title: 'Welcome Message',
          enabled: true,
          config: {
            title: 'Welcome!',
            message: 'Share links are working correctly!'
          }
        }
      ],
      triggers: [],
      created_by: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
      is_public: true,
      category: 'test',
      tags: ['test', 'share']
    };
    
    const shareId = 'test' + Math.random().toString(36).substring(2, 9);
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 30); // 30 days from now
    
    const { data, error } = await supabase
      .from('public_shares')
      .insert({
        id: shareId,
        automation_id: testAutomation.id,
        automation_data: testAutomation,
        expires_at: expiresAt.toISOString(),
        access_count: 0,
        is_active: true,
        metadata: { test: true }
      })
      .select()
      .single();
    
    if (error) {
      console.log('‚ùå Could not create test share:', error.message);
      return;
    }
    
    console.log('‚úÖ Test share created successfully!');
    console.log('\nüì± Test these share links:');
    console.log(`\nDeep Link (for app):`)
    console.log(`  zaptap://share/${data.id}`);
    console.log(`\nWeb Links (for browser):`)
    console.log(`  https://www.zaptap.cloud/share/${data.id}`);
    console.log(`  https://zaptap.cloud/share/${data.id}`);
    console.log(`  https://www.zaptap.cloud/s/${data.id}`);
    console.log(`\nShare ID: ${data.id}`);
    console.log('\nüí° Tip: Copy one of these links and test it in your app!');
    
  } catch (err) {
    console.log('‚ùå Error creating test data:', err.message);
  }
}

async function generateMigrationFile() {
  const migrationSql = `
-- App Linking Fix Migration
-- Run this in Supabase SQL Editor if the automatic fix didn't work

BEGIN;

-- 1. Create public_shares table
CREATE TABLE IF NOT EXISTS public.public_shares (
    id text PRIMARY KEY,
    automation_id uuid NOT NULL,
    automation_data jsonb NOT NULL,
    created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    expires_at timestamp with time zone NOT NULL,
    access_count integer DEFAULT 0 NOT NULL,
    is_active boolean DEFAULT true NOT NULL,
    last_accessed_at timestamp with time zone,
    metadata jsonb DEFAULT '{}' NOT NULL
);

-- 2. Create sharing_logs table
CREATE TABLE IF NOT EXISTS public.sharing_logs (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    automation_id uuid NOT NULL,
    share_id text REFERENCES public.public_shares(id) ON DELETE CASCADE,
    method text NOT NULL CHECK (method IN ('link', 'email', 'sms', 'qr', 'nfc')),
    recipients text[] DEFAULT '{}',
    shared_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
    shared_at timestamp with time zone DEFAULT now() NOT NULL,
    metadata jsonb DEFAULT '{}' NOT NULL
);

-- 3. Create indexes
CREATE INDEX IF NOT EXISTS idx_public_shares_automation_id ON public.public_shares(automation_id);
CREATE INDEX IF NOT EXISTS idx_public_shares_expires_at ON public.public_shares(expires_at);
CREATE INDEX IF NOT EXISTS idx_public_shares_is_active ON public.public_shares(is_active);
CREATE INDEX IF NOT EXISTS idx_public_shares_created_by ON public.public_shares(created_by);

CREATE INDEX IF NOT EXISTS idx_sharing_logs_automation_id ON public.sharing_logs(automation_id);
CREATE INDEX IF NOT EXISTS idx_sharing_logs_share_id ON public.sharing_logs(share_id);
CREATE INDEX IF NOT EXISTS idx_sharing_logs_shared_by ON public.sharing_logs(shared_by);
CREATE INDEX IF NOT EXISTS idx_sharing_logs_shared_at ON public.sharing_logs(shared_at DESC);

-- 4. Enable RLS
ALTER TABLE public.public_shares ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sharing_logs ENABLE ROW LEVEL SECURITY;

-- 5. Create RLS policies
CREATE POLICY "Public shares are viewable by anyone"
    ON public.public_shares FOR SELECT
    USING (is_active = true AND expires_at > now());

CREATE POLICY "Users can create their own public shares"
    ON public.public_shares FOR INSERT
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can update their own public shares"
    ON public.public_shares FOR UPDATE
    USING (auth.uid() = created_by)
    WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can delete their own public shares"
    ON public.public_shares FOR DELETE
    USING (auth.uid() = created_by);

CREATE POLICY "Anyone can increment access count"
    ON public.public_shares FOR UPDATE
    USING (is_active = true AND expires_at > now())
    WITH CHECK (
        (access_count = (OLD.access_count + 1)) AND
        (last_accessed_at = now()) AND
        (id = OLD.id) AND
        (automation_id = OLD.automation_id) AND
        (automation_data = OLD.automation_data) AND
        (created_by IS NOT DISTINCT FROM OLD.created_by) AND
        (created_at = OLD.created_at) AND
        (expires_at = OLD.expires_at) AND
        (is_active = OLD.is_active) AND
        (metadata = OLD.metadata)
    );

CREATE POLICY "Users can view their own sharing logs"
    ON public.sharing_logs FOR SELECT
    USING (auth.uid() = shared_by);

CREATE POLICY "Users can create sharing logs"
    ON public.sharing_logs FOR INSERT
    WITH CHECK (auth.uid() = shared_by);

-- 6. Create helper functions
CREATE OR REPLACE FUNCTION public.get_public_share(share_id text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    share_data jsonb;
BEGIN
    UPDATE public.public_shares
    SET 
        access_count = access_count + 1,
        last_accessed_at = now()
    WHERE 
        id = share_id AND
        is_active = true AND
        expires_at > now()
    RETURNING jsonb_build_object(
        'id', id,
        'automation_id', automation_id,
        'automation_data', automation_data,
        'created_at', created_at,
        'expires_at', expires_at,
        'access_count', access_count
    ) INTO share_data;
    
    RETURN share_data;
END;
$$;

CREATE OR REPLACE FUNCTION public.cleanup_expired_shares()
RETURNS integer
LANGUAGE plpgsql
AS $$
DECLARE
    deleted_count integer;
BEGIN
    DELETE FROM public.public_shares
    WHERE expires_at < now() - INTERVAL '7 days'
    RETURNING COUNT(*) INTO deleted_count;
    
    RETURN deleted_count;
END;
$$;

-- 7. Grant permissions
GRANT EXECUTE ON FUNCTION public.get_public_share(text) TO anon, authenticated;
GRANT EXECUTE ON FUNCTION public.cleanup_expired_shares() TO authenticated;

-- 8. Create test share
INSERT INTO public.public_shares (
    id,
    automation_id,
    automation_data,
    expires_at,
    access_count,
    is_active,
    metadata
) VALUES (
    'testshare123',
    '11111111-1111-1111-1111-111111111111',
    '{
        "id": "11111111-1111-1111-1111-111111111111",
        "title": "Test Welcome Automation",
        "description": "A test automation for verifying share links work",
        "steps": [{
            "id": "step1",
            "type": "notification",
            "title": "Welcome Message",
            "enabled": true,
            "config": {
                "title": "Welcome!",
                "message": "Share links are working correctly!"
            }
        }],
        "triggers": [],
        "is_public": true,
        "category": "test",
        "tags": ["test", "share"]
    }'::jsonb,
    now() + INTERVAL '30 days',
    0,
    true,
    '{"test": true}'::jsonb
);

COMMIT;

-- Test the share link: https://www.zaptap.cloud/share/testshare123
`;

  const fs = require('fs');
  const path = require('path');
  const migrationPath = path.join(__dirname, '..', 'supabase', 'migrations', '11_fix_app_linking.sql');
  
  try {
    fs.writeFileSync(migrationPath, migrationSql);
    console.log(`\n‚úÖ Migration file created: ${migrationPath}`);
    console.log('   Run this in Supabase SQL Editor if automatic fixes didn\'t work');
  } catch (err) {
    console.log('\nüìã Manual Migration SQL (copy and run in Supabase SQL Editor):');
    console.log(migrationSql);
  }
}

async function runFixes() {
  console.log('üöÄ Starting App Linking Fixes...\n');
  
  const steps = [
    { name: 'Create public_shares table', fn: createPublicSharesTable },
    { name: 'Create sharing_logs table', fn: createSharingLogsTable },
    { name: 'Enable RLS and create policies', fn: enableRLS },
    { name: 'Create helper functions', fn: createHelperFunctions },
    { name: 'Create test data', fn: createTestData }
  ];
  
  let successCount = 0;
  
  for (const step of steps) {
    console.log(`\nüìç Step: ${step.name}`);
    const success = await step.fn();
    if (success) successCount++;
  }
  
  // Always generate migration file as backup
  await generateMigrationFile();
  
  console.log('\n\nüìä Fix Summary:');
  console.log(`‚úÖ Completed: ${successCount}/${steps.length} steps`);
  
  if (successCount < steps.length) {
    console.log('\n‚ö†Ô∏è  Some fixes could not be applied automatically.');
    console.log('   Please run the generated migration file in Supabase SQL Editor.');
  } else {
    console.log('\nüéâ All fixes applied successfully!');
    console.log('\nüß™ Next steps:');
    console.log('1. Test the share links provided above in your app');
    console.log('2. Run the diagnostic script again to verify: npm run diagnose-linking');
    console.log('3. Create a new automation and share it to test the full flow');
  }
}

// Run all fixes
runFixes().catch(error => {
  console.error('\n‚ùå Fix script failed:', error.message);
  process.exit(1);
});