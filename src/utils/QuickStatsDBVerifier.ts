/**\n * Database Connection Verification for QuickStats Widget\n * This utility ensures the widget is properly connected to live data\n */\n\nimport { supabase } from '../../services/supabase/client';\nimport { Logger } from '../../utils/Logger';\n\nconst logger = new Logger('QuickStatsDB');\n\ninterface StatsVerification {\n  isConnected: boolean;\n  hasRecentData: boolean;\n  dataFreshness: number; // minutes since last update\n  userExecutions: number;\n  connectionQuality: 'excellent' | 'good' | 'poor' | 'offline';\n  suggestions: string[];\n}\n\nexport class QuickStatsDBVerifier {\n  /**\n   * Comprehensive database connection and data verification\n   */\n  static async verifyConnection(): Promise<StatsVerification> {\n    const startTime = Date.now();\n    const suggestions: string[] = [];\n    \n    try {\n      // Test 1: Basic connection\n      logger.info('Testing database connection...');\n      const { data: { user }, error: authError } = await supabase.auth.getUser();\n      \n      if (authError || !user) {\n        logger.warn('User not authenticated', { authError });\n        return {\n          isConnected: false,\n          hasRecentData: false,\n          dataFreshness: 0,\n          userExecutions: 0,\n          connectionQuality: 'offline',\n          suggestions: ['Sign in to see your automation statistics']\n        };\n      }\n\n      // Test 2: Check automation_executions table access\n      logger.info('Testing automation_executions table access...');\n      const { data: executions, error: executionsError } = await supabase\n        .from('automation_executions')\n        .select('id, status, execution_time, created_at')\n        .eq('user_id', user.id)\n        .order('created_at', { ascending: false })\n        .limit(1);\n        \n      const connectionTime = Date.now() - startTime;\n      let connectionQuality: 'excellent' | 'good' | 'poor' | 'offline' = 'excellent';\n      \n      if (connectionTime > 2000) connectionQuality = 'poor';\n      else if (connectionTime > 1000) connectionQuality = 'good';\n      \n      if (executionsError) {\n        logger.error('Database query failed', { error: executionsError });\n        suggestions.push('Database connection issues detected');\n        suggestions.push('Some features may be limited');\n        \n        return {\n          isConnected: true,\n          hasRecentData: false,\n          dataFreshness: 0,\n          userExecutions: 0,\n          connectionQuality: 'poor',\n          suggestions\n        };\n      }\n\n      // Test 3: Data freshness analysis\n      const today = new Date().toISOString().split('T')[0];\n      const { data: todayExecutions, error: todayError } = await supabase\n        .from('automation_executions')\n        .select('*')\n        .eq('user_id', user.id)\n        .gte('created_at', `${today}T00:00:00`)\n        .lte('created_at', `${today}T23:59:59`);\n        \n      const hasRecentData = !todayError && todayExecutions && todayExecutions.length > 0;\n      const userExecutions = todayExecutions?.length || 0;\n      \n      let dataFreshness = 0;\n      if (executions && executions.length > 0) {\n        const lastExecution = new Date(executions[0].created_at);\n        dataFreshness = Math.floor((Date.now() - lastExecution.getTime()) / (1000 * 60));\n      }\n\n      // Test 4: Check automations table for user's automations\n      const { data: userAutomations } = await supabase\n        .from('automations')\n        .select('id, title')\n        .eq('created_by', user.id)\n        .limit(5);\n\n      // Generate suggestions based on data state\n      if (userExecutions === 0) {\n        suggestions.push('Create your first automation to see statistics');\n        suggestions.push('Try using the Quick Actions to get started');\n      } else if (userExecutions < 5) {\n        suggestions.push('Run more automations to see detailed analytics');\n      }\n      \n      if (!userAutomations || userAutomations.length === 0) {\n        suggestions.push('Build your first automation for personalized stats');\n      }\n      \n      if (dataFreshness > 60) {\n        suggestions.push('Run an automation to refresh your statistics');\n      }\n\n      logger.info('Database verification completed', {\n        isConnected: true,\n        hasRecentData,\n        dataFreshness,\n        userExecutions,\n        connectionQuality,\n        connectionTime\n      });\n\n      return {\n        isConnected: true,\n        hasRecentData,\n        dataFreshness,\n        userExecutions,\n        connectionQuality,\n        suggestions\n      };\n      \n    } catch (error) {\n      logger.error('Database verification failed', { error });\n      \n      return {\n        isConnected: false,\n        hasRecentData: false,\n        dataFreshness: 0,\n        userExecutions: 0,\n        connectionQuality: 'offline',\n        suggestions: ['Connection error - check your internet', 'Try refreshing the app']\n      };\n    }\n  }\n\n  /**\n   * Test real-time data updates\n   */\n  static async testRealTimeUpdates(): Promise<boolean> {\n    try {\n      logger.info('Testing real-time subscriptions...');\n      \n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return false;\n\n      // Test subscription to automation_executions\n      const subscription = supabase\n        .channel('stats-test')\n        .on(\n          'postgres_changes',\n          {\n            event: '*',\n            schema: 'public',\n            table: 'automation_executions',\n            filter: `user_id=eq.${user.id}`\n          },\n          (payload) => {\n            logger.info('Real-time update received', { payload });\n          }\n        )\n        .subscribe();\n\n      // Clean up after test\n      setTimeout(() => {\n        subscription.unsubscribe();\n      }, 5000);\n\n      return true;\n    } catch (error) {\n      logger.error('Real-time test failed', { error });\n      return false;\n    }\n  }\n\n  /**\n   * Create sample data for testing (development only)\n   */\n  static async createSampleData(): Promise<void> {\n    if (process.env.NODE_ENV !== 'development') {\n      logger.warn('Sample data creation is only available in development');\n      return;\n    }\n    \n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) {\n        logger.error('User not authenticated for sample data creation');\n        return;\n      }\n\n      logger.info('Creating sample automation execution data...');\n      \n      // Create sample executions for today\n      const today = new Date();\n      const sampleExecutions = [];\n      \n      for (let i = 0; i < 5; i++) {\n        const executionTime = new Date(today.getTime() - (i * 2 * 60 * 60 * 1000)); // Every 2 hours\n        sampleExecutions.push({\n          user_id: user.id,\n          automation_id: '550e8400-e29b-41d4-a716-446655440004', // Use one of our fixed UUIDs\n          status: Math.random() > 0.2 ? 'success' : 'failed', // 80% success rate\n          execution_time: Math.floor(Math.random() * 2000) + 500, // 500-2500ms\n          created_at: executionTime.toISOString(),\n          context: {\n            execution_method: 'manual',\n            device_info: {\n              platform: 'mobile',\n              app_version: '1.0.0'\n            }\n          }\n        });\n      }\n\n      const { error } = await supabase\n        .from('automation_executions')\n        .insert(sampleExecutions);\n        \n      if (error) {\n        logger.error('Failed to create sample data', { error });\n      } else {\n        logger.info('Sample data created successfully', { \n          count: sampleExecutions.length \n        });\n      }\n    } catch (error) {\n      logger.error('Sample data creation failed', { error });\n    }\n  }\n\n  /**\n   * Get detailed analytics for debugging\n   */\n  static async getDebugAnalytics(): Promise<any> {\n    try {\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return null;\n\n      const [executionsResult, automationsResult] = await Promise.all([\n        supabase\n          .from('automation_executions')\n          .select('*')\n          .eq('user_id', user.id)\n          .order('created_at', { ascending: false })\n          .limit(10),\n        supabase\n          .from('automations')\n          .select('*')\n          .eq('created_by', user.id)\n          .limit(5)\n      ]);\n\n      return {\n        user: {\n          id: user.id,\n          email: user.email,\n          created_at: user.created_at\n        },\n        recentExecutions: executionsResult.data || [],\n        userAutomations: automationsResult.data || [],\n        executionsError: executionsResult.error,\n        automationsError: automationsResult.error\n      };\n    } catch (error) {\n      logger.error('Debug analytics failed', { error });\n      return null;\n    }\n  }\n}\n\nexport default QuickStatsDBVerifier;\n